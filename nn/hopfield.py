# autogenerated


class HopfieldNetwork:
    def __init__(self, num_neurons):
        self.num_neurons = num_neurons
        self.weights = [[0] * num_neurons for _ in range(num_neurons)]

    def train(self, patterns):
        for pattern in patterns:
            for i in range(self.num_neurons):
                for j in range(self.num_neurons):
                    if i == j:
                        continue
                    self.weights[i][j] += pattern[i] * pattern[j]

    def predict(self, pattern):
        updated_pattern = list(pattern)
        for _ in range(10):  # Run for a few iterations (adjust as needed)
            for i in range(self.num_neurons):
                net = sum(self.weights[i][j] * updated_pattern[j] for j in range(self.num_neurons))
                updated_pattern[i] = 1 if net >= 0 else -1
        return updated_pattern



