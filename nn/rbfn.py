# autogenerated


import math
import random

class RBFN:
    def __init__(self, input_size, hidden_size, output_size):
        self.input_size = input_size
        self.hidden_size = hidden_size
        self.output_size = output_size

        # Initialize random centers and widths for the radial basis functions
        self.centers = [tuple(random.uniform(-1, 1) for _ in range(input_size)) for _ in range(hidden_size)]
        self.widths = [random.uniform(0.1, 1) for _ in range(hidden_size)]

        # Initialize random weights and biases for the output layer
        self.weights = [random.uniform(-1, 1) for _ in range(hidden_size)]
        self.bias = random.uniform(-1, 1)

    def _radial_basis(self, x, center, width):
        return math.exp(-sum((xi - ci) ** 2 / (2 * width ** 2) for xi, ci in zip(x, center)))

    def forward(self, inputs):
        hidden_layer = [self._radial_basis(inputs, center, width) for center, width in zip(self.centers, self.widths)]
        output_layer = sum(w * h for w, h in zip(self.weights, hidden_layer)) + self.bias
        return output_layer

    def train(self, inputs, target, learning_rate=0.1):
        hidden_layer = [self._radial_basis(inputs, center, width) for center, width in zip(self.centers, self.widths)]
        output_layer = sum(w * h for w, h in zip(self.weights, hidden_layer)) + self.bias

        error = target - output_layer

        # Update the weights and biases using the error and hidden layer activations
        self.weights = [w + learning_rate * error * h for w, h in zip(self.weights, hidden_layer)]
        self.bias += learning_rate * error

